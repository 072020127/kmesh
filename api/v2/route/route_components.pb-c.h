/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: api/route/route_components.proto */

#ifndef PROTOBUF_C_api_2froute_2froute_5fcomponents_2eproto__INCLUDED
#define PROTOBUF_C_api_2froute_2froute_5fcomponents_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Route__VirtualHost Route__VirtualHost;
typedef struct _Route__Route Route__Route;
typedef struct _Route__RouteMatch Route__RouteMatch;
typedef struct _Route__RouteAction Route__RouteAction;
typedef struct _Route__RetryPolicy Route__RetryPolicy;


/* --- enums --- */


/* --- messages --- */

struct  _Route__VirtualHost
{
  ProtobufCMessage base;
  char *name;
  size_t n_domains;
  char **domains;
  size_t n_routes;
  Route__Route **routes;
};
#define ROUTE__VIRTUAL_HOST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&route__virtual_host__descriptor) \
    , (char *)protobuf_c_empty_string, 0,NULL, 0,NULL }


struct  _Route__Route
{
  ProtobufCMessage base;
  char *name;
  Route__RouteMatch *match;
  Route__RouteAction *route;
};
#define ROUTE__ROUTE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&route__route__descriptor) \
    , (char *)protobuf_c_empty_string, NULL, NULL }


struct  _Route__RouteMatch
{
  ProtobufCMessage base;
  char *prefix;
};
#define ROUTE__ROUTE_MATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&route__route_match__descriptor) \
    , (char *)protobuf_c_empty_string }


struct  _Route__RouteAction
{
  ProtobufCMessage base;
  char *cluster;
  uint32_t timeout;
  Route__RetryPolicy *retry_policy;
};
#define ROUTE__ROUTE_ACTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&route__route_action__descriptor) \
    , (char *)protobuf_c_empty_string, 0, NULL }


struct  _Route__RetryPolicy
{
  ProtobufCMessage base;
  /*
   *RetryPriority retry_priority = 4;
   */
  uint32_t num_retries;
};
#define ROUTE__RETRY_POLICY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&route__retry_policy__descriptor) \
    , 0 }


/* Route__VirtualHost methods */
void   route__virtual_host__init
                     (Route__VirtualHost         *message);
size_t route__virtual_host__get_packed_size
                     (const Route__VirtualHost   *message);
size_t route__virtual_host__pack
                     (const Route__VirtualHost   *message,
                      uint8_t             *out);
size_t route__virtual_host__pack_to_buffer
                     (const Route__VirtualHost   *message,
                      ProtobufCBuffer     *buffer);
Route__VirtualHost *
       route__virtual_host__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   route__virtual_host__free_unpacked
                     (Route__VirtualHost *message,
                      ProtobufCAllocator *allocator);
/* Route__Route methods */
void   route__route__init
                     (Route__Route         *message);
size_t route__route__get_packed_size
                     (const Route__Route   *message);
size_t route__route__pack
                     (const Route__Route   *message,
                      uint8_t             *out);
size_t route__route__pack_to_buffer
                     (const Route__Route   *message,
                      ProtobufCBuffer     *buffer);
Route__Route *
       route__route__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   route__route__free_unpacked
                     (Route__Route *message,
                      ProtobufCAllocator *allocator);
/* Route__RouteMatch methods */
void   route__route_match__init
                     (Route__RouteMatch         *message);
size_t route__route_match__get_packed_size
                     (const Route__RouteMatch   *message);
size_t route__route_match__pack
                     (const Route__RouteMatch   *message,
                      uint8_t             *out);
size_t route__route_match__pack_to_buffer
                     (const Route__RouteMatch   *message,
                      ProtobufCBuffer     *buffer);
Route__RouteMatch *
       route__route_match__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   route__route_match__free_unpacked
                     (Route__RouteMatch *message,
                      ProtobufCAllocator *allocator);
/* Route__RouteAction methods */
void   route__route_action__init
                     (Route__RouteAction         *message);
size_t route__route_action__get_packed_size
                     (const Route__RouteAction   *message);
size_t route__route_action__pack
                     (const Route__RouteAction   *message,
                      uint8_t             *out);
size_t route__route_action__pack_to_buffer
                     (const Route__RouteAction   *message,
                      ProtobufCBuffer     *buffer);
Route__RouteAction *
       route__route_action__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   route__route_action__free_unpacked
                     (Route__RouteAction *message,
                      ProtobufCAllocator *allocator);
/* Route__RetryPolicy methods */
void   route__retry_policy__init
                     (Route__RetryPolicy         *message);
size_t route__retry_policy__get_packed_size
                     (const Route__RetryPolicy   *message);
size_t route__retry_policy__pack
                     (const Route__RetryPolicy   *message,
                      uint8_t             *out);
size_t route__retry_policy__pack_to_buffer
                     (const Route__RetryPolicy   *message,
                      ProtobufCBuffer     *buffer);
Route__RetryPolicy *
       route__retry_policy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   route__retry_policy__free_unpacked
                     (Route__RetryPolicy *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Route__VirtualHost_Closure)
                 (const Route__VirtualHost *message,
                  void *closure_data);
typedef void (*Route__Route_Closure)
                 (const Route__Route *message,
                  void *closure_data);
typedef void (*Route__RouteMatch_Closure)
                 (const Route__RouteMatch *message,
                  void *closure_data);
typedef void (*Route__RouteAction_Closure)
                 (const Route__RouteAction *message,
                  void *closure_data);
typedef void (*Route__RetryPolicy_Closure)
                 (const Route__RetryPolicy *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor route__virtual_host__descriptor;
extern const ProtobufCMessageDescriptor route__route__descriptor;
extern const ProtobufCMessageDescriptor route__route_match__descriptor;
extern const ProtobufCMessageDescriptor route__route_action__descriptor;
extern const ProtobufCMessageDescriptor route__retry_policy__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_api_2froute_2froute_5fcomponents_2eproto__INCLUDED */
