/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: api/workloadapi/authorization.proto */

#ifndef PROTOBUF_C_api_2fworkloadapi_2fauthorization_2eproto__INCLUDED
#define PROTOBUF_C_api_2fworkloadapi_2fauthorization_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Kmesh__Security__Authorization Kmesh__Security__Authorization;
typedef struct _Kmesh__Security__Rule Kmesh__Security__Rule;
typedef struct _Kmesh__Security__Clause Kmesh__Security__Clause;
typedef struct _Kmesh__Security__Match Kmesh__Security__Match;
typedef struct _Kmesh__Security__Address Kmesh__Security__Address;
typedef struct _Kmesh__Security__StringMatch Kmesh__Security__StringMatch;


/* --- enums --- */

typedef enum _Kmesh__Security__Scope {
  /*
   * ALL means that the authorization policy will be applied to all workloads
   * in the mesh (any namespace).
   */
  KMESH__SECURITY__SCOPE__GLOBAL = 0,
  /*
   * NAMESPACE means that the policy will only be applied to workloads in a
   * specific namespace.
   */
  KMESH__SECURITY__SCOPE__NAMESPACE = 1,
  /*
   * WORKLOAD_SELECTOR means that the policy will only be applied to specific
   * workloads that were selected by their labels.
   */
  KMESH__SECURITY__SCOPE__WORKLOAD_SELECTOR = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(KMESH__SECURITY__SCOPE)
} Kmesh__Security__Scope;
typedef enum _Kmesh__Security__Action {
  /*
   * Allow the request if it matches with the rules.
   */
  KMESH__SECURITY__ACTION__ALLOW = 0,
  /*
   * Deny the request if it matches with the rules.
   */
  KMESH__SECURITY__ACTION__DENY = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(KMESH__SECURITY__ACTION)
} Kmesh__Security__Action;

/* --- messages --- */

struct  _Kmesh__Security__Authorization
{
  ProtobufCMessage base;
  char *name;
  char *namespace_;
  /*
   * Determine the scope of this RBAC policy.
   * If set to NAMESPACE, the 'namespace' field value will be used.
   */
  Kmesh__Security__Scope scope;
  /*
   * The action to take if the request is matched with the rules.
   * Default is ALLOW if not specified.
   */
  Kmesh__Security__Action action;
  /*
   * Set of RBAC policy rules each containing its cluases (To, From, When).
   * If at least one of the rules is matched the policy action will
   * take place.
   * Rules are OR-ed.
   */
  size_t n_rules;
  Kmesh__Security__Rule **rules;
};
#define KMESH__SECURITY__AUTHORIZATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__authorization__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, KMESH__SECURITY__SCOPE__GLOBAL, KMESH__SECURITY__ACTION__ALLOW, 0,NULL }


struct  _Kmesh__Security__Rule
{
  ProtobufCMessage base;
  /*
   * Clauses are AND-ed
   * This is a generic form of the authz policy's to, from and when
   */
  size_t n_clauses;
  Kmesh__Security__Clause **clauses;
};
#define KMESH__SECURITY__RULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__rule__descriptor) \
    , 0,NULL }


struct  _Kmesh__Security__Clause
{
  ProtobufCMessage base;
  /*
   * The logical behavior between the matches (if there are more than one)
   *  MatchBehavior match_behavior = 1;
   * Matches are OR-ed
   * Match is a generic form of the authz policy's expressions contained in To, From and When.
   */
  size_t n_matches;
  Kmesh__Security__Match **matches;
};
#define KMESH__SECURITY__CLAUSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__clause__descriptor) \
    , 0,NULL }


struct  _Kmesh__Security__Match
{
  ProtobufCMessage base;
  size_t n_namespaces;
  Kmesh__Security__StringMatch **namespaces;
  size_t n_not_namespaces;
  Kmesh__Security__StringMatch **not_namespaces;
  size_t n_principals;
  Kmesh__Security__StringMatch **principals;
  size_t n_not_principals;
  Kmesh__Security__StringMatch **not_principals;
  size_t n_source_ips;
  Kmesh__Security__Address **source_ips;
  size_t n_not_source_ips;
  Kmesh__Security__Address **not_source_ips;
  size_t n_destination_ips;
  Kmesh__Security__Address **destination_ips;
  size_t n_not_destination_ips;
  Kmesh__Security__Address **not_destination_ips;
  size_t n_destination_ports;
  uint32_t *destination_ports;
  size_t n_not_destination_ports;
  uint32_t *not_destination_ports;
};
#define KMESH__SECURITY__MATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__match__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }


struct  _Kmesh__Security__Address
{
  ProtobufCMessage base;
  ProtobufCBinaryData address;
  uint32_t length;
};
#define KMESH__SECURITY__ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__address__descriptor) \
    , {0,NULL}, 0 }


typedef enum {
  KMESH__SECURITY__STRING_MATCH__MATCH_TYPE__NOT_SET = 0,
  KMESH__SECURITY__STRING_MATCH__MATCH_TYPE_EXACT = 1,
  KMESH__SECURITY__STRING_MATCH__MATCH_TYPE_PREFIX = 2,
  KMESH__SECURITY__STRING_MATCH__MATCH_TYPE_SUFFIX = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(KMESH__SECURITY__STRING_MATCH__MATCH_TYPE)
} Kmesh__Security__StringMatch__MatchTypeCase;

struct  _Kmesh__Security__StringMatch
{
  ProtobufCMessage base;
  Kmesh__Security__StringMatch__MatchTypeCase match_type_case;
  union {
    /*
     * exact string match
     */
    char *exact;
    /*
     * prefix-based match
     */
    char *prefix;
    /*
     * suffix-based match
     */
    char *suffix;
  };
};
#define KMESH__SECURITY__STRING_MATCH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&kmesh__security__string_match__descriptor) \
    , KMESH__SECURITY__STRING_MATCH__MATCH_TYPE__NOT_SET, {0} }


/* Kmesh__Security__Authorization methods */
void   kmesh__security__authorization__init
                     (Kmesh__Security__Authorization         *message);
size_t kmesh__security__authorization__get_packed_size
                     (const Kmesh__Security__Authorization   *message);
size_t kmesh__security__authorization__pack
                     (const Kmesh__Security__Authorization   *message,
                      uint8_t             *out);
size_t kmesh__security__authorization__pack_to_buffer
                     (const Kmesh__Security__Authorization   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__Authorization *
       kmesh__security__authorization__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__authorization__free_unpacked
                     (Kmesh__Security__Authorization *message,
                      ProtobufCAllocator *allocator);
/* Kmesh__Security__Rule methods */
void   kmesh__security__rule__init
                     (Kmesh__Security__Rule         *message);
size_t kmesh__security__rule__get_packed_size
                     (const Kmesh__Security__Rule   *message);
size_t kmesh__security__rule__pack
                     (const Kmesh__Security__Rule   *message,
                      uint8_t             *out);
size_t kmesh__security__rule__pack_to_buffer
                     (const Kmesh__Security__Rule   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__Rule *
       kmesh__security__rule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__rule__free_unpacked
                     (Kmesh__Security__Rule *message,
                      ProtobufCAllocator *allocator);
/* Kmesh__Security__Clause methods */
void   kmesh__security__clause__init
                     (Kmesh__Security__Clause         *message);
size_t kmesh__security__clause__get_packed_size
                     (const Kmesh__Security__Clause   *message);
size_t kmesh__security__clause__pack
                     (const Kmesh__Security__Clause   *message,
                      uint8_t             *out);
size_t kmesh__security__clause__pack_to_buffer
                     (const Kmesh__Security__Clause   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__Clause *
       kmesh__security__clause__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__clause__free_unpacked
                     (Kmesh__Security__Clause *message,
                      ProtobufCAllocator *allocator);
/* Kmesh__Security__Match methods */
void   kmesh__security__match__init
                     (Kmesh__Security__Match         *message);
size_t kmesh__security__match__get_packed_size
                     (const Kmesh__Security__Match   *message);
size_t kmesh__security__match__pack
                     (const Kmesh__Security__Match   *message,
                      uint8_t             *out);
size_t kmesh__security__match__pack_to_buffer
                     (const Kmesh__Security__Match   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__Match *
       kmesh__security__match__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__match__free_unpacked
                     (Kmesh__Security__Match *message,
                      ProtobufCAllocator *allocator);
/* Kmesh__Security__Address methods */
void   kmesh__security__address__init
                     (Kmesh__Security__Address         *message);
size_t kmesh__security__address__get_packed_size
                     (const Kmesh__Security__Address   *message);
size_t kmesh__security__address__pack
                     (const Kmesh__Security__Address   *message,
                      uint8_t             *out);
size_t kmesh__security__address__pack_to_buffer
                     (const Kmesh__Security__Address   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__Address *
       kmesh__security__address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__address__free_unpacked
                     (Kmesh__Security__Address *message,
                      ProtobufCAllocator *allocator);
/* Kmesh__Security__StringMatch methods */
void   kmesh__security__string_match__init
                     (Kmesh__Security__StringMatch         *message);
size_t kmesh__security__string_match__get_packed_size
                     (const Kmesh__Security__StringMatch   *message);
size_t kmesh__security__string_match__pack
                     (const Kmesh__Security__StringMatch   *message,
                      uint8_t             *out);
size_t kmesh__security__string_match__pack_to_buffer
                     (const Kmesh__Security__StringMatch   *message,
                      ProtobufCBuffer     *buffer);
Kmesh__Security__StringMatch *
       kmesh__security__string_match__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   kmesh__security__string_match__free_unpacked
                     (Kmesh__Security__StringMatch *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Kmesh__Security__Authorization_Closure)
                 (const Kmesh__Security__Authorization *message,
                  void *closure_data);
typedef void (*Kmesh__Security__Rule_Closure)
                 (const Kmesh__Security__Rule *message,
                  void *closure_data);
typedef void (*Kmesh__Security__Clause_Closure)
                 (const Kmesh__Security__Clause *message,
                  void *closure_data);
typedef void (*Kmesh__Security__Match_Closure)
                 (const Kmesh__Security__Match *message,
                  void *closure_data);
typedef void (*Kmesh__Security__Address_Closure)
                 (const Kmesh__Security__Address *message,
                  void *closure_data);
typedef void (*Kmesh__Security__StringMatch_Closure)
                 (const Kmesh__Security__StringMatch *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    kmesh__security__scope__descriptor;
extern const ProtobufCEnumDescriptor    kmesh__security__action__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__authorization__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__rule__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__clause__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__match__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__address__descriptor;
extern const ProtobufCMessageDescriptor kmesh__security__string_match__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_api_2fworkloadapi_2fauthorization_2eproto__INCLUDED */
